<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>My Baking Timer</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#c9a574">

<link rel="icon" type="image/png" href="breadroll.png"/>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
<style>
html, body {
  height: 100%; margin: 0;
  display: flex; flex-direction: column;
  font-family: 'Poppins', sans-serif;
  background: linear-gradient(180deg, #faf7f2, #f2e7dc);
  color: #2e2e2e;
}
header {
  background: linear-gradient(90deg, #e6d5c3, #c9a574);
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  position: sticky; top: 0; z-index: 100;
}
.navbar { display:flex; align-items:center; justify-content:space-between; max-width:1200px; margin:0 auto; padding:0.4rem 1.5rem;}
.navbar .logo img { height:45px; }
.navbar .links { display:flex; gap:2rem; flex-wrap:wrap; }
.navbar .links a { position:relative; text-decoration:none; font-weight:500; color:#2e2e2e; padding-bottom:2px; transition:color 0.3s; font-size:0.95rem; }
.navbar .links a::after { content:""; position:absolute; width:0%; height:2px; bottom:0; left:0; background-color:#6b4b2c; transition:width 0.3s ease; }
.navbar .links a:hover::after, .navbar .links a.active::after { width:100%; }
.navbar .links a.active { color:#6b4b2c; }
.navbar .links button { padding:0.2rem 0.5rem; background:linear-gradient(90deg, #a6e4a0, #f3604d); color:#fff; font-weight:500; border-radius:50px; text-decoration:none; font-size:0.85rem; align-items:center; justify-content:center; transition: background 0.3s, transform 0.2s; }
.navbar .links button:hover { background:linear-gradient(90deg, #96eb78, #3164f1); transform: scale(1.05); }
.navbar .actions .btn { padding:0.4rem 1rem; background:linear-gradient(90deg, #6b4b2c, #4a3320); color:#fff; font-weight:600; border-radius:50px; text-decoration:none; font-size:0.85rem; display:inline-flex; align-items:center; justify-content:center; transition: background 0.3s, transform 0.2s; }
.navbar .actions .btn:hover { background:linear-gradient(90deg, #4a3320, #2e1f12); transform: scale(1.05); }

main { flex:1; display:flex; flex-direction:column; align-items:center; padding:2rem; background:#f5ede2; }
#timersWrapper { display:flex; flex-wrap:wrap; gap:20px; justify-content:center; width:100%; max-width: 1200px; }
.timer-container { text-align:center; max-width:420px; width:100%; padding:2rem; background:rgba(255,255,255,0.85); border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.08); backdrop-filter:blur(6px); animation: fadeIn 0.8s ease; }
.timer-row{display:flex;gap:.5rem;align-items:center;justify-content:center; flex-wrap: wrap;}
.timer-row input.timerName,
.timer-row select.soundSelect{flex: 1 1 150px; min-width: 120px; box-sizing: border-box; padding:8px;border-radius:8px;border:2px solid #ccc;background:#fff;font-size:.95rem}
.timer-row input.timerName:focus, .timer-row select.soundSelect:focus{border-color:#b85c38}

.timer-container h2 { margin-bottom:15px; font-size:1.5rem; color:#6b4b2c; }
/* .timer-container input.timerName { width:100%; margin-bottom:10px; padding:6px 10px; font-size:1rem; border:2px solid #ccc; border-radius:8px; outline:none; text-align:center; box-sizing:border-box; } */
/* .timer-container input.timerName:focus { border-color:#b85c38; } */
/* .timer-container select.soundSelect {
  margin-bottom: 10px;
  padding: 6px 10px;
  font-size: 0.95rem;
  border-radius: 8px;
  border: 2px solid #ccc;
  outline: none;
  width: 100%;
  background-color: #fff;
  color: #333;
} */
.soundSelect:focus { border-color:#b85c38; }

.timeDisplay { font-size:3rem; font-weight:bold; margin:15px 0; color:#b85c38; }

.input-group {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-bottom: 15px;
  flex-wrap: wrap;
}
.time-input {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 70px;
}
.time-input input {
  width: 70px;
  text-align: center;
  font-size: 1rem;
  padding: 6px;
  border-radius: 8px;
  border: 2px solid #ccc;
  outline: none;
  margin-top:5px;
}
.time-input button {
  width: 70px;
  padding: 8px 0;
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 10px;
  border: 1px solid #999;
  background: linear-gradient(145deg, #f0d9b5, #caa885);
  color: #3e2f1c;
  box-shadow: 2px 2px 5px rgba(0,0,0,0.15), -2px -2px 5px rgba(255,255,255,0.6);
  user-select: none;
  transition: transform 0.15s, box-shadow 0.15s;
}
.time-input button:hover {
  transform: scale(1.05);
  box-shadow: 3px 3px 6px rgba(0,0,0,0.2), -3px -3px 6px rgba(255,255,255,0.7);
}
.time-input .decBtn {
  margin-top:5px;
  background: linear-gradient(145deg, #caa885, #f0d9b5);
}

.time-input button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.timer-controls { display:flex; justify-content:center; gap:10px; flex-wrap:wrap; margin-top:10px; }
.timer-controls button { padding:8px 16px; border:none; border-radius:10px; color:#fff; cursor:pointer; font-size:0.95rem; font-weight:600; transition: transform 0.2s, opacity 0.2s; }
.startBtn { background:#3cb371; } .pauseBtn { background:#ffa500; } .resetBtn { background:#d9534f; } .closeBtn { background:#888; }
.timer-controls button:hover { transform:scale(1.05); opacity:0.9; }

#addTimerBtn { margin-bottom:20px; padding:10px 20px; border:none; border-radius:50px; font-weight:600; cursor:pointer; background:linear-gradient(90deg,#3cb371,#2e8b57); color:#fff; transition:transform 0.2s; }
#addTimerBtn:hover { transform:scale(1.05); }

footer { text-align:center; background:linear-gradient(90deg, #e6d5c3, #c9a574); color:#2e2e2e; padding:0.5rem 0; font-size:0.75rem; margin-top:auto; }
.mobile-nav { position:fixed; bottom:34px; left:50%; transform:translateX(-50%); background:linear-gradient(90deg, #6b4b2c, #4a3320); color:#fff !important; font-weight:700; text-shadow:1px 1px 2px rgba(0,0,0,0.3); padding:0.75rem 1.4rem; border-radius:50px; text-decoration:none; font-size:0.75rem; box-shadow:0 4px 8px rgba(0,0,0,0.25); z-index:999; transition: transform 0.2s, opacity 0.2s; }
.mobile-nav a:visited { color:#fff !important; }
.mobile-nav:hover { transform:translateX(-50%) scale(1.05); opacity:0.9; }

@media (min-width:769px) { .mobile-nav { display:none; } }
@media (max-width:768px) {
  .navbar .links { gap:1.2rem; } 
  .navbar .links a { font-size:0.85rem; } 
  /* .navbar .links button { padding:0.2rem 0.5rem; background:linear-gradient(90deg, #a6e4a0, #f3604d); color:#fff; font-weight:600; border-radius:50px; text-decoration:none; font-size:0.85rem; align-items:center; justify-content:center; transition: background 0.3s, transform 0.2s; }
  .navbar .links button:hover { background:linear-gradient(90deg, #d5eecc, #54eb6d); transform: scale(1.05); } */
  .navbar .actions { display:none; }
  .timer-container { max-width:100%; padding:1rem; }
  .timeDisplay { font-size:2rem; margin:10px 0; }
  .time-input input { width:60px; }
  .time-input button { width:60px; font-size:0.85rem; }
}

@media (max-width: 480px) {
  .timer-row input.timerName {
    max-width: 55%;
  }
  .timer-row select.soundSelect {
    max-width: 40%;
  }
}


@keyframes fadeIn { from {opacity:0; transform:translateY(20px);} to {opacity:1; transform:translateY(0);} }

.toast {
  position: fixed;
  bottom: 20px;
  right: 10px;
  background: #6b4b2c;
  color: #fff;
  padding: 6px 9px;
  border-radius: 8px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.3);
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.4s, transform 0.4s;
  z-index: 9999;
  font-weight: 500;
  font-size: small;
}
.toast.show {
  opacity: 1;
  transform: translateY(0);
}

/* ---------- Bell icon animation ---------- */
.bell {
  display: inline-block;
  margin-left: 6px;
  font-size: 1.4em;
  transform-origin: top center;
}

/* When timer finishes */
.bell.ringing {
  animation: bellRing 0.25s infinite ease-in-out;
}

@keyframes bellRing {
  0%   { transform: rotate(0deg); }
  25%  { transform: rotate(25deg); }
  50%  { transform: rotate(0deg); }
  75%  { transform: rotate(-25deg); }
  100% { transform: rotate(0deg); }
}




</style>
</head>
<body>
<header>
  <div class="navbar">
    <div class="logo"><a href="./index.html"><img src="logo4.png" alt="KCSR Breads Logo" /></a></div>
    <nav class="links">
      <a href="./index.html">Home</a>
      <a href="./about.html">About Us</a>
      <a href="./timer.html" class="active">My Baking Timer</a>
      <button id="installBtn" style="display:none;">üì≤</button>
    </nav>
    <div class="actions"><a href="./index.html" class="btn">üõí Shop Now</a>
    </div>
  </div>
</header>

<main>
  <button id="addTimerBtn">‚ûï Add Timer</button>

  <div id="timersWrapper">
    <div class="timer-container">
       <div class="timer-row">
      <input type="text" class="timerName" placeholder="Optional: Timer Name">
      <select class="soundSelect">
        <option value="sounds/alarmdigital.mp3">Digital Beep</option>
        <option value="sounds/huntrix_golden.mp3">Huntrix</option>
        <option value="sounds/SodaPop.mp3">Soda</option>
        <option value="sounds/timer1.mp3">Timer 1</option>
        <option value="sounds/timer2.mp3">Timer 2</option>
        <option value="sounds/timer3.mp3">Timer 3</option>
      </select>
      </div>

      <h2>‚è≤Ô∏è My Baking Timer 1</h2>

      <div class="input-group">
        <div class="time-input">
          <button class="incBtn">HR</button>
          <input type="number" class="hoursInput" min="0" max="23" value="0">
          <button class="decBtn">‚ñº</button>
        </div>
        <div class="time-input">
          <button class="incBtn">MIN</button>
          <input type="number" class="minutesInput" min="0" max="59" value="0">
          <button class="decBtn">‚ñº</button>
        </div>
        <div class="time-input">
          <button class="incBtn">SEC</button>
          <input type="number" class="secondsInput" min="0" max="59" value="0">
          <button class="decBtn">‚ñº</button>
        </div>
      </div>

      <div class="timeDisplay">00:00:00</div>

      <div class="timer-controls">
        <button class="startBtn">‚ñ∂ Start</button>
        <button class="pauseBtn">‚è∏ Pause</button>
        <button class="resetBtn">‚èπ Stop/Reset</button>
        <button class="closeBtn">‚ùå Close</button>
      </div>
    </div>
  </div>

  <!-- <div class="actions">
    <button id="installBtn" style="display:none;" class="btn">üì≤ Install App</button>
  </div> -->

</main>

<footer>&copy; 2025 KCSR Breads atbp. All rights reserved.</footer>
<nav id="mobileNav" class="mobile-nav">
  <a href="./index.html">üßÅ Get Baked Goodies</a>
</nav>

<audio id="dingSound" preload="auto">
  <source src="/breads/sounds/alarmdigital.mp3" type="audio/mpeg">
</audio>

<script>
// -----------------------
// Persistent Baking Timers
// -----------------------

// storage key
const TIMERS_KEY = "kcsr_baking_timers_v1";

// global object to track any currently playing audio per timer
const activeAudios = new Map();

// ‚úÖ Preload all sound files once (keep same list as before)
const soundPaths = [
  "/breads/sounds/alarmdigital.mp3",
  "/breads/sounds/huntrix_golden.mp3",
  "/breads/sounds/SodaPop.mp3",
  "/breads/sounds/timer1.mp3",
  "/breads/sounds/timer2.mp3",
  "/breads/sounds/timer3.mp3"
];

const preloadedAudios = {};
soundPaths.forEach(path => {
  const audio = new Audio(path);
  audio.preload = "auto";
  preloadedAudios[path] = audio;
});

// helper to normalize selected sound value to an absolute path we preloaded
function normalizeSoundPath(selected) {
  if (!selected) return soundPaths[0] || "/breads/sounds/alarmdigital.mp3";
  // selected may be "sounds/..." or "/breads/sounds/..."
  if (selected.startsWith("/")) return selected;
  return "/breads/" + selected.replace(/^\/?/, "");
}

function playAlarmSound(timerId, soundUrl, bellElem) {
  stopAlarmSound(timerId);

  const fullPath = normalizeSoundPath(soundUrl);
  const audio = preloadedAudios[fullPath] 
    ? preloadedAudios[fullPath].cloneNode(true)
    : new Audio(fullPath);

  audio.preload = "auto";
  audio.loop = true;
  audio.volume = 1.0;
  audio.muted = false;

  audio.play().catch(() => {
    showToast("‚ö†Ô∏è Sound unavailable offline or autoplay blocked. Tap to allow audio.");
  });
  activeAudios.set(timerId, audio);

  if (bellElem) bellElem.classList.add("ringing");
  return audio;
}

function stopAlarmSound(timerId) {
  const audio = activeAudios.get(timerId);
  if (audio) {
    try {
      audio.pause();
      audio.currentTime = 0;
      audio.loop = false;
    } catch(e){}
  }
  activeAudios.delete(timerId);
}

// Unlock audio on first interaction (some mobile browsers require it)
const playSilentUnlock = () => {
  const ding = document.getElementById('dingSound');
  if (!ding) return;
  ding.play().then(()=>{ ding.pause(); ding.currentTime=0; }).catch(()=>{});
};
document.body.addEventListener('click', playSilentUnlock, { once: true });

// Toast helper (unchanged styling usage)
let toastOffset = 0;
function showToast(msg, withStopButton = false, audio = null, timerId = null) {
  const toast = document.createElement("div");
  toast.className = "toast";
  toast.style.left = "50%";
  toast.style.transform = "translateX(-50%)";
  toast.style.bottom = `${20 + toastOffset}px`;

  if (withStopButton && audio) {
    toast.innerHTML = `
      <span>${msg}</span>
      <button style="
        background: linear-gradient(90deg, #c0392b, #e74c3c);
        color: #fff;
        border: none;
        padding: 6px 14px;
        border-radius: 20px;
        margin-left: 12px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.85rem;
        box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        transition: transform 0.2s ease, opacity 0.2s ease;
      ">Stop</button>
    `;

    const stopBtn = toast.querySelector("button");
    stopBtn.addEventListener("click", () => {
      try {
        audio.pause();
        audio.currentTime = 0;
        audio.loop = false;
      } catch(e){}
      if (timerId !== null) stopAlarmSound(timerId);
      toast.remove();
      showToast("‚úÖ Sound stopped.");
    });

    stopBtn.addEventListener("mouseenter", () => {
      stopBtn.style.transform = "scale(1.05)";
      stopBtn.style.opacity = "0.9";
    });
    stopBtn.addEventListener("mouseleave", () => {
      stopBtn.style.transform = "scale(1)";
      stopBtn.style.opacity = "1";
    });
  } else {
    toast.textContent = msg;
  }

  document.body.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add("show"));

  setTimeout(() => {
    toast.classList.remove("show");
    setTimeout(() => toast.remove(), 400);
  }, 4000);

  toastOffset += 70;
  setTimeout(() => (toastOffset = Math.max(0, toastOffset - 70)), 4000);
}

// --------------------
// Persistent store
// --------------------
function saveTimersToStorage(timersArray) {
  try {
    localStorage.setItem(TIMERS_KEY, JSON.stringify(timersArray));
  } catch (e) {
    console.warn("Could not save timers:", e);
  }
}

function loadTimersFromStorage() {
  try {
    const raw = localStorage.getItem(TIMERS_KEY);
    if (!raw) return [];
    return JSON.parse(raw) || [];
  } catch (e) {
    console.warn("Could not load timers:", e);
    return [];
  }
}

function removeTimerFromStorage(id) {
  const arr = loadTimersFromStorage().filter(t => t.id !== id);
  saveTimersToStorage(arr);
}

// --------------------
// DOM helpers
// --------------------
const timersWrapper = document.getElementById("timersWrapper");
let timerCount = 1; // used for default display numbering

function createTimerElement() {
  const el = document.createElement("div");
  el.className = "timer-container";
  el.innerHTML = `
    <div class="timer-row">
      <input type="text" class="timerName" placeholder="Optional: Timer Name">
      <select class="soundSelect" aria-label="Select sound">
        <option value="sounds/alarmdigital.mp3">Digital Beep</option>
        <option value="sounds/huntrix_golden.mp3">Huntrix</option>
        <option value="sounds/SodaPop.mp3">Soda</option>
        <option value="sounds/timer1.mp3">Timer 1</option>
        <option value="sounds/timer2.mp3">Timer 2</option>
        <option value="sounds/timer3.mp3">Timer 3</option>
      </select>
    </div>
    <h2></h2>
    <div class="input-group">
      <div class="time-input">
        <button class="incBtn">HR</button>
        <input type="number" class="hoursInput" min="0" max="23" value="0">
        <button class="decBtn">‚ñº</button>
      </div>
      <div class="time-input">
        <button class="incBtn">MIN</button>
        <input type="number" class="minutesInput" min="0" max="59" value="0">
        <button class="decBtn">‚ñº</button>
      </div>
      <div class="time-input">
        <button class="incBtn">SEC</button>
        <input type="number" class="secondsInput" min="0" max="59" value="0">
        <button class="decBtn">‚ñº</button>
      </div>
    </div>
    <div class="timeDisplay">00:00:00</div>
    <div class="timer-controls">
      <button class="startBtn">‚ñ∂ Start</button>
      <button class="pauseBtn">‚è∏ Pause</button>
      <button class="resetBtn">‚èπ Stop/Reset</button>
      <button class="closeBtn">‚ùå Close</button>
    </div>
  `;
  return el;
}

// --------------------
// Timer creation logic with persistence
// --------------------
function createTimer(container, number, state = null) {
  // internal runtime state for this timer
  // If `state` is provided, it is the persisted state object loaded from localStorage.
  // persisted state fields we expect:
  // { id, name, sound, duration, mode, startTime, pausedAt, running, pausedRemaining, offsetSeconds, createdAt }
  let timer = null;
  let resetClickedOnce = false;

  // DOM refs
  const timerNameInput = container.querySelector(".timerName");
  const hoursInput = container.querySelector(".hoursInput");
  const minutesInput = container.querySelector(".minutesInput");
  const secondsInput = container.querySelector(".secondsInput");
  const timeDisplay = container.querySelector(".timeDisplay");
  const startBtn = container.querySelector(".startBtn");
  const pauseBtn = container.querySelector(".pauseBtn");
  const resetBtn = container.querySelector(".resetBtn");
  const closeBtn = container.querySelector(".closeBtn");
  const soundSelect = container.querySelector(".soundSelect");
  const title = container.querySelector("h2");

  const defaultName = `Timer ${number}`;
  if (title) title.innerHTML = `‚è≤Ô∏è <span class="timer-label">${defaultName}</span> <span class="bell">üîî</span>`;

  // persisted id (generate if none)
  const id = (state && state.id) ? state.id : `timer_${Date.now()}_${Math.floor(Math.random()*9999)}`;

  // persisted fields with defaults
  let name = (state && state.name) || "";
  let sound = (state && state.sound) || "sounds/alarmdigital.mp3";
  let duration = (state && typeof state.duration === "number") ? state.duration : 0; // seconds for countdown
  let mode = (state && state.mode) || "countdown"; // "countdown" or "stopwatch"
  let startTime = (state && state.startTime) || null; // timestamp ms when running started
  let pausedAt = (state && state.pausedAt) || null; // timestamp ms when paused
  let running = !!(state && state.running);
  let pausedRemaining = (state && typeof state.pausedRemaining === "number") ? state.pausedRemaining : null; // seconds left for countdown when paused
  let offsetSeconds = (state && typeof state.offsetSeconds === "number") ? state.offsetSeconds : 0; // for stopwatch stored elapsed when paused
  let alarmAudio = null;
  let finished = !!(state && state.finished);

  // populate DOM from state (if available)
  if (name) {
    timerNameInput.value = name;
    const h2 = container.querySelector("h2");
    if (h2) h2.innerHTML = `‚è≤Ô∏è ${name} <span class="bell">üîî</span>`;
  }

  // set sound select (use relative values like 'sounds/..' as your UI uses)
  if (soundSelect) {
    // pick the option that matches either the relative or absolute form
    const rel = sound.startsWith("/breads/") ? sound.replace("/breads/", "") : sound;
    const option = Array.from(soundSelect.options).find(o => o.value === rel || o.value === sound);
    if (option) soundSelect.value = option.value;
  }

  // if there's a saved duration, set inputs accordingly (duration in seconds)
  if (typeof duration === "number" && duration > 0) {
    const h = Math.floor(duration / 3600);
    const m = Math.floor((duration % 3600) / 60);
    const s = duration % 60;
    hoursInput.value = String(h);
    minutesInput.value = String(m);
    secondsInput.value = String(s);
  }

  // Update header when timer name changes (keep bell)
  timerNameInput.addEventListener('input', () => {
    name = timerNameInput.value || "";
    const h2 = container.querySelector("h2");
    const disp = name || defaultName;
    if (h2) h2.innerHTML = `‚è≤Ô∏è ${disp} <span class="bell">üîî</span>`;
    persistState();
  });

  // Update selected sound when user changes dropdown
  if (soundSelect) {
    soundSelect.addEventListener('change', () => {
      sound = soundSelect.value;
      persistState();
      // warm-up preload if available
      const full = normalizeSoundPath(sound);
      if (preloadedAudios[full]) {
        // nothing else needed
      }
    });
  }

  // Increment/decrement buttons behavior (unchanged)
  container.querySelectorAll(".incBtn, .decBtn").forEach(btn=>{
    let interval;
    const input = btn.closest(".time-input").querySelector("input");
    const step = btn.classList.contains("incBtn") ? 1 : -1;
    const min = parseInt(input.min);
    const max = parseInt(input.max);

    const change = () => {
      let val = parseInt(input.value) || 0;
      val += step;
      val = Math.min(max, Math.max(min, val));
      input.value = val;
      persistInputsToDuration(); // update duration from inputs
      updateDisplay();
    };

    btn.addEventListener("mousedown", ()=>{ change(); interval=setInterval(change,150); });
    btn.addEventListener("mouseup", ()=>clearInterval(interval));
    btn.addEventListener("mouseleave", ()=>clearInterval(interval));
    btn.addEventListener("touchstart", e=>{ e.preventDefault(); change(); interval=setInterval(change,150); }, {passive:false});
    btn.addEventListener("touchend", ()=>clearInterval(interval));
  });

  function persistInputsToDuration() {
    const h = parseInt(hoursInput.value) || 0;
    const m = parseInt(minutesInput.value) || 0;
    const s = parseInt(secondsInput.value) || 0;
    duration = h*3600 + m*60 + s;
    if (duration <= 0) {
      mode = "stopwatch"; // when user sets 0 length, treat as stopwatch
    } else {
      mode = "countdown";
    }
    persistState();
  }

  // stop alarm audio for this timer
  function stopAlarmAudioLocal() {
    if (alarmAudio) {
      try {
        alarmAudio.pause();
        alarmAudio.currentTime = 0;
        alarmAudio.loop = false;
      } catch(e){}
      alarmAudio = null;
    }
    const bell = container.querySelector(".bell");
    if (bell) bell.classList.remove("ringing");
  }

  // Display update uses the persisted runtime fields and current time
  function updateDisplay() {
    let dispSeconds = 0;

    if (running) {
      // compute from startTime
      const now = Date.now();
      if (mode === "stopwatch") {
        // elapsed = offsetSeconds + (now - startTime)
        const elapsed = offsetSeconds + Math.floor((now - startTime) / 1000);
        dispSeconds = Math.max(0, elapsed);
      } else {
        // countdown: remaining = pausedRemaining (if paused before) or duration - elapsed
        const elapsed = Math.floor((now - startTime) / 1000);
        const remaining = Math.max(0, duration - elapsed);
        dispSeconds = remaining;
        if (remaining <= 0) {
          // finished: handle finish once
          finishTimer();
          return;
        }
      }
    } else {
      // not running: show paused value or input values
      if (pausedAt !== null) {
        // timer was paused: show pausedRemaining for countdown or offsetSeconds for stopwatch
        if (mode === "stopwatch") {
          dispSeconds = offsetSeconds;
        } else {
          dispSeconds = (typeof pausedRemaining === "number") ? pausedRemaining : duration;
        }
      } else {
        // never started: show input values or zero
        if (mode === "stopwatch" && offsetSeconds > 0) {
          dispSeconds = offsetSeconds;
        } else {
          // composition of inputs
          const h = parseInt(hoursInput.value) || 0;
          const m = parseInt(minutesInput.value) || 0;
          const s = parseInt(secondsInput.value) || 0;
          dispSeconds = h*3600 + m*60 + s;
        }
      }
    }

    // format HH:MM:SS
    const hh = Math.floor(dispSeconds / 3600);
    const mm = Math.floor((dispSeconds % 3600) / 60);
    const ss = dispSeconds % 60;
    timeDisplay.textContent = `${String(hh).padStart(2,"0")}:${String(mm).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;

    // disable decrement if at min
    container.querySelectorAll(".time-input").forEach(ti=>{
      const input = ti.querySelector("input");
      const decBtn = ti.querySelector(".decBtn");
      if (input && decBtn) decBtn.disabled = parseInt(input.value) <= parseInt(input.min);
    });
  }

  // Called when a countdown reaches zero
  function finishTimer() {
    // prevent multiple calls
    if (!running && (!startTime || finished)) return;
    finished = true;
    running = false;
    clearInterval(timer);
    stopAlarmAudioLocal(); // ensure no previous audio playing
    const bell = container.querySelector(".bell");
    alarmAudio = playAlarmSound(id, soundSelect ? soundSelect.value : sound, bell);
    const nameToShow = timerNameInput.value.trim() || defaultName;
    showToast(`‚è∞ ${nameToShow} done! Check your bread!`, true, alarmAudio, id);
    // persist finished state
    persistState();
  }

  // Start/resume
  startBtn.addEventListener("click", () => {
    // determine mode and duration from inputs if never set
    persistInputsToDuration();

    if (running) return;

    // If previously finished, reset finished flag
    if (finished) finished = false;

    const now = Date.now();

    if (pausedAt) {
      // resuming -> compute how to set startTime based on pause values
      if (mode === "stopwatch") {
        // offsetSeconds already has the elapsed time at pause
        startTime = now - (offsetSeconds * 1000);
      } else {
        // countdown: pausedRemaining stored at pause
        // Set startTime so that remaining = pausedRemaining at current time
        startTime = now - ((duration - pausedRemaining) * 1000);
      }
      pausedAt = null;
    } else {
      // fresh start
      if (mode === "stopwatch") {
        offsetSeconds = 0;
        startTime = now;
      } else {
        // countdown: if user set inputs and duration > 0, we set startTime so full duration will elapse
        startTime = now;
      }
    }

    running = true;

    // save state immediately
    persistState();

    // visual tick every second (the calculation uses Date.now(), so it's robust to throttling)
    timer = setInterval(() => {
      updateDisplay();
    }, 1000);
    updateDisplay(); // immediate update
  });

  // Pause
  pauseBtn.addEventListener("click", () => {
    if (!running) return;
    running = false;
    clearInterval(timer);
    pausedAt = Date.now();

    // compute pausedRemaining or offsetSeconds
    const now = Date.now();
    if (mode === "stopwatch") {
      offsetSeconds = Math.floor((now - startTime) / 1000);
    } else {
      const elapsed = Math.floor((now - startTime) / 1000);
      const remaining = Math.max(0, duration - elapsed);
      pausedRemaining = remaining;
    }

    persistState();
    updateDisplay();
  });

  // Reset (1 click stop, 2 clicks full reset)
  resetBtn.addEventListener("click", () => {
    clearInterval(timer);
    running = false;
    pausedAt = null;
    stopAlarmAudioLocal();

    if(!resetClickedOnce){
      const nameToShow = timerNameInput.value.trim() || defaultName;
      showToast(`‚èπ ${nameToShow} stopped. Click again to reset.`);
      resetClickedOnce = true;
      setTimeout(()=>resetClickedOnce=false,4000);
      // persist stop state
      persistState();
      return;
    }

    // Full reset:
    hoursInput.value = '0';
    minutesInput.value = '0';
    secondsInput.value = '0';
    duration = 0;
    mode = "stopwatch";
    offsetSeconds = 0;
    pausedRemaining = null;
    startTime = null;
    pausedAt = null;
    finished = false;

    updateDisplay();
    persistState();
    showToast("üîÅ Timer fully reset.");
    resetClickedOnce = false;
  });

  // Close (remove timer)
  if (closeBtn) {
    closeBtn.addEventListener("click", () => {
      running = false;
      clearInterval(timer);
      stopAlarmAudioLocal();
      container.remove();
      removeTimerFromStorage(id);
    });
  }

  // persist current state to localStorage
  function persistState() {
    // load existing array, replace or append
    const arr = loadTimersFromStorage();
    const stateObj = {
      id,
      name: timerNameInput.value || "",
      sound: soundSelect ? soundSelect.value : sound,
      duration: duration,
      mode: mode,
      startTime: startTime || null,
      pausedAt: pausedAt || null,
      running: !!running,
      pausedRemaining: (typeof pausedRemaining === "number") ? pausedRemaining : null,
      offsetSeconds: offsetSeconds || 0,
      finished: !!finished,
      createdAt: (state && state.createdAt) ? state.createdAt : (Date.now())
    };

    const idx = arr.findIndex(t => t.id === id);
    if (idx >= 0) arr[idx] = stateObj;
    else arr.push(stateObj);
    saveTimersToStorage(arr);
  }

  // initial display and tick setup based on restored state
  function initializeFromRestored() {
    // if there's a saved running flag, we must compute correct runtime values
    if (running && startTime) {
      // compute how much time passed while we were closed
      const now = Date.now();
      if (mode === "stopwatch") {
        // offsetSeconds remains as is (if it existed) and elapsed becomes offset + (now-startTime)
        // no change needed; updateDisplay will compute using startTime and offsetSeconds
      } else {
        // countdown: check if it reached zero while we were away
        const elapsed = Math.floor((now - startTime) / 1000);
        const remaining = duration - elapsed;
        if (remaining <= 0) {
          // expired while away ‚Äî mark finished and trigger alarm now
          finished = true;
          running = false;
          startTime = null;
          pausedAt = null;
          pausedRemaining = 0;
          persistState();
          // trigger alarm immediately
          const bell = container.querySelector(".bell");
          alarmAudio = playAlarmSound(id, soundSelect ? soundSelect.value : sound, bell);
          const nameToShow = timerNameInput.value.trim() || defaultName;
          showToast(`‚è∞ ${nameToShow} done while you were away!`, true, alarmAudio, id);
          updateDisplay();
          return;
        }
        // otherwise: it is still running: start interval and update
        timer = setInterval(() => updateDisplay(), 1000);
      }
    } else {
      // if paused and we have pausedRemaining or offsetSeconds, keep those shown
      // else nothing to do
    }
    updateDisplay();
  }

  // on creation, persist initial state (so timers survive reloads even before starting)
  persistState();

  // initialize increment/decrement behaviour reads inputs -> update duration
  persistInputsToDuration();

  // If this timer was created from a saved state, ensure the visual clock is resumed appropriately
  initializeFromRestored();

  // expose updateDisplay to outside (not necessary but useful)
  return {
    id,
    container,
    updateDisplay,
    persistState
  };
}

// --------------------
// Restore timers from storage on load
// --------------------
function restoreAllTimersOnLoad() {
  const saved = loadTimersFromStorage();

  // If storage has saved timers, replace the current DOM with those timers
  if (saved.length > 0) {
    timersWrapper.innerHTML = ""; // clear static initial DOM to avoid duplication
    timerCount = 1;
    saved.forEach(st => {
      const el = createTimerElement();
      timersWrapper.appendChild(el);
      createTimer(el, timerCount++, st);
    });
    return;
  }

  // else: no saved timers -> wire existing DOM timer(s)
  document.querySelectorAll(".timer-container").forEach((t) => {
    createTimer(t, timerCount++);
  });
}

// Restore on DOM content loaded
document.addEventListener("DOMContentLoaded", () => {
  restoreAllTimersOnLoad();
});

// When user adds a new timer via button
document.getElementById("addTimerBtn").addEventListener("click", ()=> {
  const newTimer = createTimerElement();
  timersWrapper.appendChild(newTimer);
  createTimer(newTimer, timerCount++);
});

// Run ensureOfflineSounds from your previous code (keeps same behavior)
async function ensureOfflineSounds() {
  const soundUrls = [
    '/breads/sounds/alarmdigital.mp3',
    '/breads/sounds/huntrix_golden.mp3',
    '/breads/sounds/SodaPop.mp3',
    '/breads/sounds/timer1.mp3',
    '/breads/sounds/timer2.mp3',
    '/breads/sounds/timer3.mp3'
  ];

  try {
    const cache = await caches.open('baking-timer-v6');
    for (const url of soundUrls) {
      const match = await cache.match(url);
      if (!match) {
        const resp = await fetch(url);
        if (resp.ok) {
          await cache.put(url, resp.clone());
          console.log('üéµ Added missing sound:', url);
        }
      }
    }
  } catch (err) {
    console.warn('‚ö†Ô∏è Could not verify sound cache:', err);
  }
}
window.addEventListener('load', () => {
  if (navigator.onLine) ensureOfflineSounds();
});

// Keep your PWA/install and service worker registration logic intact below
let deferredPrompt;
const installBtn = document.getElementById("installBtn");
const APP_URL = "https://kcsrtreasures.github.io/breads/timer.html";
if (installBtn) installBtn.style.display = "inline-block";
function isInAppBrowser() {
  const ua = navigator.userAgent || navigator.vendor || window.opera;
  return /FBAN|FBAV|Instagram|Messenger/i.test(ua);
}
function isStandalone() {
  return (
    window.matchMedia("(display-mode: standalone)").matches ||
    navigator.standalone === true
  );
}
window.addEventListener("beforeinstallprompt", (e) => {
  e.preventDefault();
  deferredPrompt = e;
  if (installBtn) installBtn.disabled = false;
});
if (installBtn) {
  installBtn.addEventListener("click", async () => {
    if (isStandalone()) {
      showToast("‚úÖ App is already installed. Checking for updates...");
      if (navigator.serviceWorker?.controller) {
        navigator.serviceWorker.controller.postMessage({ type: "CHECK_FOR_UPDATE" });
      }
      return;
    }
    if (isInAppBrowser()) {
      showToast("‚ö†Ô∏è Redirecting to Chrome for installation...");
      setTimeout(() => {
        const isAndroid = /Android/i.test(navigator.userAgent);
        if (isAndroid) {
          const intentURL = `intent://${APP_URL.replace(/^https?:\/\//, "")}#Intent;scheme=https;package=com.android.chrome;end`;
          window.location.href = intentURL;
        } else {
          window.open(APP_URL, "_blank");
        }
      }, 800);
      return;
    }
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      if (outcome === "accepted") {
        showToast("üéâ App installing...");
      } else {
        showToast("‚ÑπÔ∏è Installation canceled.");
      }
      deferredPrompt = null;
      return;
    }
    window.location.href = APP_URL;
  });
}
window.addEventListener("appinstalled", () => {
  showToast("‚úÖ App installed successfully!");
  localStorage.setItem("pwaInstalled", "true");
  if (installBtn) installBtn.style.display = "inline-block";
});
window.addEventListener("load", () => {
  if (isStandalone()) localStorage.setItem("pwaInstalled", "true");
  if (installBtn) installBtn.style.display = "inline-block";
});

// Service worker register (keep existing behavior)
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker
      .register("/breads/service-worker.js")
      .then((reg) => {
        console.log("‚úÖ Service Worker registered:", reg.scope);
        reg.onupdatefound = () => {
          const newSW = reg.installing;
          if (newSW) {
            newSW.onstatechange = () => {
              if (newSW.state === "installed" && navigator.serviceWorker.controller) {
                showToast("üîÑ New version available! Please refresh or reinstall the app.");
              }
            };
          }
        };
        navigator.serviceWorker.addEventListener("message", (event) => {
          if (event.data && event.data.type === "CHECK_FOR_UPDATE") {
            reg.update();
          }
        });
      })
      .catch((err) => console.log("‚ùå SW registration failed:", err));

    navigator.serviceWorker.addEventListener("controllerchange", () => {
      console.log("‚ôªÔ∏è Service Worker activated ‚Äî reloading page...");
      window.location.reload();
    });
  });
}
</script>


</body>
</html>
